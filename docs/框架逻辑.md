好的，我完全明白你的需求了。你需要一个宏大、统一、且可扩展的**逻辑框架**来驱动《奥术学院扑克》中所有守护灵、法术和法器的效果。这个框架的核心思想是**数据驱动**：效果的“做什么”和“数值是多少”定义在`.tres`资源文件中，而“怎么做”的逻辑则由一个中央系统来统一执行。

这不仅仅是功能的罗列，而是一套设计哲学和技术实现蓝图。

---

## 🎭 奥术学院扑克 - 统一能力效果框架 (Unified Ability Effect Framework)

### 核心设计哲学

1.  **数据驱动 (Data-Driven)**：所有能力（法器、法术、守护灵、卡牌强化）的**行为类型** (`effect_type`) 和**效果参数** (`effect_value`) 都在资源文件 (`.tres`) 中定义。游戏设计师无需编写代码，只需修改或创建资源文件即可调整平衡或添加新能力。
2.  **事件驱动 (Event-Driven)**：游戏中的每个关键节点（如回合开始、抽牌、打出牌型、结算分数、回合结束）都会发出一个**全局信号（事件）**。能力系统会监听这些事件，并激活那些`trigger_timing`（触发时机）匹配的能力。
3.  **逻辑集中 (Centralized Logic)**：所有`effect_type`的具体实现逻辑都集中在一个或少数几个核心管理器中（我们称之为`EffectExecutor`）。这避免了代码分散，使得添加新效果类型和调试变得极其简单。

### 统一效果模型

每个可触发的效果都可以被抽象成一个简单的结构：

```gdscript
# 这不是一个实际的类，而是一个概念模型
class Effect:
    var effect_type: String  # 效果的唯一标识符，如 "ADD_KNOWLEDGE_POINTS"
    var effect_value        # 效果的参数，可以是整数、浮点数、字符串或数组
    var source_object       # 效果的来源，如某个法器或守护灵
    var context             # 效果发生时的上下文信息，如打出的牌、当前牌型等
```

### 巨大的逻辑框架：效果类型分类与实现逻辑

下面，我将为你构建这个“巨大的逻辑框架”。它将所有GDD中的效果划分为几大类，并为每个具体效果定义了`effect_type` ID和实现逻辑的思路。

---

#### 第1大类：资源与游戏状态操控 (Resource & State Manipulation)

这类效果直接影响玩家的核心资源或游戏进程的状态。

| `effect_type` ID | `effect_value` 示例 | 实现逻辑（在`EffectExecutor`中） | GDD 示例 |
| :--- | :--- | :--- | :--- |
| **`ADD_KNOWLEDGE_POINTS`** | `int` (如 `10`) | `GameManager.knowledge_points += effect_value` | **法术**: 灵感碎片, **蜡封**: 红色蜡封 |
| **`ADD_KNOWLEDGE_POINTS_PERCENT`** | `float` (如 `0.05`) | `GameManager.knowledge_points += (points_gained_this_turn * effect_value)` | **法器**: 魔力水晶 |
| **`DRAW_CARDS`** | `int` (如 `1`) | `DeckManager.draw_cards(effect_value)` | **蜡封**: 蓝色蜡封, **法术**: 灵感闪现 |
| **`DISCARD_CARDS`** | `Dictionary` (如 `{ "count": 2, "from": "hand" }`) | `HandManager.prompt_discard(effect_value.count)` | **法术**: 魔力汲取 |
| **`MODIFY_HAND_LIMIT_TEMP`** | `int` (如 `2`) | 在回合开始时 `HandManager.temp_hand_limit_modifier += effect_value`，回合结束时重置。 | **守护灵**: 知识窃贼 |
| **`MODIFY_HAND_LIMIT_PERM`** | `int` (如 `1`) | `HandManager.permanent_hand_limit_modifier += effect_value` | **守护灵**: 共振核心 |
| **`MODIFY_ARTIFACT_SLOTS`** | `int` (如 `1`) | `GameManager.artifact_slots += effect_value`，并更新UI。 | **考核奖励**, **法器**: 无尽之匣 |
| **`MODIFY_SPELL_SLOTS`** | `int` (如 `1`) | `GameManager.spell_slots += effect_value`，并更新UI。 | **考核奖励**, **法器**: 空间袋 |
| **`MODIFY_GUARDIAN_SLOTS`** | `int` (如 `1`) | `GameManager.guardian_slots += effect_value`，并更新UI。 | **考核奖励**, **法器**: 唤灵吊坠 |
| **`GRANT_FREE_DISCARD`** | `int` (如 `1`) | `GameManager.free_discards_this_turn += effect_value` | **Buff**: 灵感迸发 |
| **`RECOVER_SPELL_CHARGE`** | `int` (如 `1`) | `SpellManager.recover_random_spell_charge(effect_value)` | **法器**: 能量循环器 |

---

#### 第2大类：得分计算干预 (Score Calculation Intervention)

这类效果在`8.4 学识点分数计算逻辑`的特定步骤中介入，直接影响最终得分。

| `effect_type` ID | `effect_value` 示例 | 实现逻辑（在`ScoreCalculator`中） | GDD 示例 |
| :--- | :--- | :--- | :--- |
| **`ADD_SCORE_BASE`** | `int` (如 `20`) | **步骤2**: `current_score += effect_value` (在乘以等级倍率前) | **蜡封**: 紫色蜡封, **法器**: 贤者之石 |
| **`MULTIPLY_SCORE_BASE`** | `float` (如 `2.0`) | **步骤2**: `current_score *= effect_value` (在乘以等级倍率前) | **法术**: 灵光一闪 |
| **`ADD_SCORE_FINAL`** | `int` (如 `10`) | **步骤5**: `final_score += effect_value` (在所有倍率计算后) | **法器**: 学徒笔记, **守护灵**: 丰饶之手 |
| **`MULTIPLY_SCORE_FINAL`** | `float` (如 `1.5`) | **步骤4**: `final_multiplier_product *= effect_value` | **牌框**: 黄金牌框, **守护灵**: 幸运妖精 |
| **`SET_HAND_LEVEL_TEMP`** | `int` (如 `5`) | **步骤3**: 计算牌型等级倍率时，强制使用 `level = effect_value` | **法术**: 秘法爆发 |
| **`TRANSFORM_HAND_TYPE`** | `Dictionary` (如 `{ "from": "TWO_PAIR", "to": "FULL_HOUSE" }`) | **步骤1**: 牌型识别后，如果牌型是`from`，则强制替换为`to`再计算。 | **法器**: 双子法典 |
| **`ADD_SCORE_PER_CARD_PROPERTY`** | `Dictionary` (如 `{"property": "stone_frame", "amount": 5}`) | **步骤5**: 检查打出的牌，若有牌满足`property`，`final_score += amount` | **法器**: 符文精粹 |

---

#### 第3大类：卡牌与牌库操控 (Card & Deck Manipulation)

这类效果对牌库、手牌、弃牌堆中的卡牌进行移动、复制、销毁等操作。

| `effect_type` ID | `effect_value` 示例 | 实现逻辑（在`EffectExecutor`中） | GDD 示例 |
| :--- | :--- | :--- | :--- |
| **`SEARCH_DECK`** | `Dictionary` (如 `{"filter": "any", "target": "hand"}`) | 弹出牌库浏览器UI，让玩家选择一张牌，移动到手牌。`filter`可指定牌或属性。 | **法术**: 精准抽牌 |
| **`RECOVER_FROM_DISCARD`** | `Dictionary` (如 `{"filter": "any", "count": 1, "target": "hand"}`) | 弹出弃牌堆UI，让玩家选择`count`张牌，移动到手牌。 | **法术**: 完美记忆 |
| **`COPY_CARD_PERMANENT`** | `Dictionary` (如 `{"source": "hand", "target": "deck"}`) | 弹出UI让玩家选择手牌，`DeckManager.add_card(selected_card.clone())` | **法术**: 永恒复制 |
| **`COPY_CARD_TEMPORARY`** | `Dictionary` (如 `{"source": "hand", "target": "hand"}`) | 弹出UI选择手牌，`HandManager.add_card(temp_clone)`，临时卡牌在回合结束时销毁。 | **法术**: 灵魂链接 |
| **`DESTROY_CARD`** | `Dictionary` (如 `{"source": "deck", "filter": "any", "count": 1}`) | 弹出UI选择牌库中的牌，`DeckManager.destroy_card(selected_card)`。 | **法术**: 解构术, 湮灭之手 |
| **`RESHUFFLE_DISCARD_INTO_DECK`**| `null` | `DeckManager.reshuffle_discard_pile()` | **法术**: 时空回溯 |
| **`VIEW_DECK_TOP`** | `int` (如 `3`) | `DeckManager.peek_top(effect_value)`，并显示在UI上供玩家操作（重排/弃置）。 | **法术**: 次级预言 |
| **`RETURN_TO_DECK_BOTTOM`** | `(self)` | 在卡牌效果结算时，不进入弃牌堆，而是`DeckManager.add_to_bottom(self)`。 | **材质**: 岩石材质 |

---

#### 第4大类：卡牌本体修改 (Card Modification)

这类效果直接改变卡牌自身的属性或附加物，可以是永久或临时的。

| `effect_type` ID | `effect_value` 示例 | 实现逻辑（在`EffectExecutor`或`Card`类中） | GDD 示例 |
| :--- | :--- | :--- | :--- |
| **`ADD_ENHANCEMENT`** | `Dictionary` (如 `{"type": "seal", "value": "red"}`) | 弹出UI选择手牌，`selected_card.add_enhancement(enhancement_data)`。 | **法术**: 符文强化, 奥能镀层 |
| **`MODIFY_CARD_VALUE_TEMP`** | `int` (如 `3`) | 弹出UI选择手牌，`selected_card.add_temp_modifier("value", effect_value)`，回合结束移除。 | **法术**: 牌面增幅 |
| **`MODIFY_CARD_SUIT_TEMP`** | `String` (如 `"hearts"`) | 弹出UI选择手牌，`selected_card.add_temp_modifier("suit", effect_value)`，回合结束移除。 | **法术**: 元素重构 |
| **`MODIFY_CARD_VALUE_PERM`** | `int` (如 `2`) | `card.base_value += effect_value`。这在卡牌被创建时应用。 | **牌框**: 石质牌框 |
| **`COPY_EFFECT_ON_PLAY`** | `null` | 卡牌被打出时，在计算前，视为有两张此牌。这是`ScoreCalculator`需要处理的特殊逻辑。 | **蜡封**: 金色蜡封 |
| **`DUPLICATE_VALUE_ON_SUCCESS`** | `float` (如 `2.0`) | 卡牌使用后，若未被摧毁，其基础效果翻倍。这个逻辑在卡牌本身结算后触发。 | **材质**: 玻璃材质 |
| **`PREVENT_DESTRUCTION`** | `null` | 在任何销毁逻辑（如玻璃材质）检查时，如果此牌有该效果，则跳过销毁。 | **牌框**: 银质牌框 |

---

#### 第5大类：元游戏与规则扭曲 (Meta & Rule-Bending)

这类效果影响游戏的永久进度或扭曲基本规则。

| `effect_type` ID | `effect_value` 示例 | 实现逻辑（在`EffectExecutor`中） | GDD 示例 |
| :--- | :--- | :--- | :--- |
| **`LEVEL_UP_HAND_TYPE`** | `Dictionary` (如 `{"type": "THREE_KIND", "levels": 1}`) | `HandRankingManager.level_up(effect_value.type, effect_value.levels)` | **派系**: 符文学派, **考核奖励** |
| **`MODIFY_SHOP_COST_PERCENT`** | `float` (如 `-0.2`) | 在生成商店物品时，`item.cost *= (1 + effect_value)` | **Buff**: 智慧之风 |
| **`MODIFY_SHOP_RARITY_CHANCE`** | `Dictionary` (如 `{"rarity": "epic", "mod": 0.1}`) | 在生成商店物品时，调整稀有度权重。 | **Buff**: 星辰指引 |
| **`REDUCE_BOSS_REQUIREMENT`** | `float` (如 `-0.25`) | 在进入冬季考核时，`boss.target_score *= (1 + effect_value)` | **Buff**: 考前冲刺 |
| **`TRIGGER_RANDOM_EFFECT`** | `Array` (如 `["ADD_SEAL", "GAIN_XP"]`) | 从`effect_value`数组中随机选择一个`effect_type`来执行。 | **通用逻辑**：用于各种随机奖励 |
| **`GRANT_PLAYER_CHOICE`** | `Array` (如 `["LEVEL_UP_PAIR", "LEVEL_UP_FLUSH"]`) | 暂停游戏，弹出UI让玩家从`effect_value`提供的选项中选择一个奖励。 | **考核奖励**: 第五学年 |

---

### 工作流程示例：实现“火焰之心”法器

1.  **创建资源文件 (`assets/data/artifacts/heart_of_flame.tres`)**

    ```tres
    [gd_resource type="Resource" script_class="ArtifactData" load_steps=2 format=3]

    [ext_resource type="Script" path="res://cs/卡牌系统/数据/ArtifactData.gd" id="1_data"]

    [resource]
    script = ExtResource("1_data")
    id = "ARTIFACT_HEART_OF_FLAME"
    name = "火焰之心"
    description = "所有“红桃”牌在计算牌型时，点数被视为+1。"
    rarity = 1  # 稀有
    cost = 30
    effect_type = "MODIFY_CARD_PROPERTY_CONDITIONAL" # 我们定义一个新的、更精确的类型
    effect_value = {
        "condition": {"property": "suit", "is": "hearts"},
        "modification": {"property": "value", "add": 1}
    }
    # 这个效果是持续性的，在每次牌型计算时都应用，所以不需要trigger_timing
    ```

2.  **在 `ScoreCalculator` 中实现逻辑**

    在牌型识别的最开始阶段，需要一个预处理步骤来应用所有这类条件性修改。

    ```gdscript
    # in ScoreCalculator.gd or a new CardPreprocessor.gd
    static func preprocess_cards_for_scoring(cards: Array) -> Array:
        var processed_cards = []
        var active_artifacts = GameManager.get_equipped_artifacts()

        for card in cards:
            var modified_card = card.clone_for_calculation() # 创建临时拷贝用于计算
            
            for artifact in active_artifacts:
                if artifact.effect_type == "MODIFY_CARD_PROPERTY_CONDITIONAL":
                    var effect = artifact.effect_value
                    var condition = effect.condition
                    var modification = effect.modification

                    # 检查条件是否满足 (e.g., 是不是红桃?)
                    if modified_card.get(condition.property) == condition.is:
                        # 应用修改 (e.g., 点数+1)
                        var current_val = modified_card.get(modification.property)
                        modified_card.set(modification.property, current_val + modification.add)

            processed_cards.append(modified_card)
        
        return processed_cards
    ```

3.  **游戏流程**
    *   玩家购买并装备“火焰之心”。
    *   当玩家打出5张牌进行研习时，`ScoreCalculator`首先调用`preprocess_cards_for_scoring`。
    *   该函数遍历激活的法器，找到“火焰之心”。
    *   它检查被打出的5张牌，如果某张牌是红桃，就创建一个它的临时计算版本，其点数+1。
    *   后续的牌型识别（顺子、对子等）将基于这些被临时修改过的点数进行，从而实现了法器的效果。

### 总结

这个框架将所有复杂、多样的能力效果，归纳为**有限的、可管理的逻辑类别**。

*   **对游戏设计师**：极度友好。他们只需要在`effect_type`的“菜单”中选择，并填写`effect_value`，就能创造出GDD中描述的几乎所有能力。
*   **对程序员**：清晰明了。新功能的开发，通常只是意味着在这个框架的某个类别下，新增一个`effect_type`的实现逻辑，而不用去修改游戏流程中零散的各个部分。
*   **对游戏本身**：健壮且可扩展。未来要加入新的DLC、新的派系或新的能力，都可以在这个坚实的基础上进行，而不会导致代码混乱和技术债务。

这，就是你所需要的那个“特殊的巨大的逻辑框架”。