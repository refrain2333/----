---
描述: 阶段二首批任务（ScoreCalculator → GameManager → UI）
---

# 阶段二首批任务详细设计

> 实施顺序：**1. ScoreCalculator 扩展 → 2. GameManager 重构 → 3. UI 场景流转**
>
> 目标：先打通核心评分与流程逻辑，再绑定 UI，符合自下而上的开发模式。

---

## 1. 扩展 ScoreCalculator.gd（牌型等级倍率系统）

### 1.1 目标
- 在现有基础分的计算上，叠加“牌型等级倍率”以反映玩家对某牌型的研习程度。

### 1.2 数据来源
- `GameConfig.card_type_base_scores : Dictionary<String,int>`
- `GameConfig.card_type_level_multipliers : Dictionary<String,Array<float>>`  (长度=5，对应 LV1–LV5)
- `GameManager.card_type_levels : Dictionary<String,int>`  (LV1–LV5)

### 1.3 新接口
```gdscript	extends Node
class_name ScoreCalculator

# 返回单一牌型得分
static func calculate_single_type(type_name:String, level:int, base_scores:Dictionary, multipliers:Dictionary) -> int

# 计算一组卡牌组合分数（入口）
static func calculate_combination_score(cards:Array) -> int
```

### 1.4 实现要点
1. 保留现有基础分计算逻辑；将“组合 → 牌型”检测拆分为独立工具方法。
2. 根据检测结果 `type_name`：
   - `base_score = game_config.card_type_base_scores[type_name]`
   - `level = GameManager.card_type_levels.get(type_name, 1)`
   - `multiplier = game_config.card_type_level_multipliers[type_name][level-1]`
   - `total = base_score * multiplier`
3. 返回 `total`，并在 `GameManager` 中使用。

### 1.5 测试方案
- 在 `res://debug/score_test.tscn` 中编写脚本：
  1. 生成若干手牌组合，设定不同 `card_type_levels`。
  2. 打印 `calculate_combination_score()` 结果，校对手工计算。
- 单元测试脚本位于 `test/score_calculator_test.gd`。

---

## 2. 重构 GameManager.gd（精简职责 + 流程实现）

### 2.1 目标
- 移除牌库/得分/Buff 细节，专注“时间线 & 玩家资源”。
- 与 `ScoreCalculator`, `CardManager`, `EventManager` 解耦，通过信号交互。

### 2.2 步骤
1. **字段替换**
   - 删除 `focus_count / essence_count / mana` 等旧变量。
   - 新增/保留：`lore_points`, `current_year`, `current_term`, `player_score`, `card_type_levels`。
2. **流程方法实现**
```gdscript
func start_new_year():
    current_year += 1
    emit_signal("new_year_started", current_year)

func start_term(term:int):
    current_term = term
    emit_signal("term_started", current_term)

func end_term():
    emit_signal("term_ended")

func start_wisdom_hall():
    emit_signal("wisdom_hall_opened")

func start_assessment():
    player_score = 0
    emit_signal("assessment_started", current_year)
```
3. **分数更新入口**
```gdscript
func on_cards_played(cards:Array):
    var add_score = ScoreCalculator.calculate_combination_score(cards)
    player_score += add_score
    emit_signal("game_state_changed", get_state_snapshot())
```
4. **信号订阅**
   - 订阅 `CardManager.cards_played` → 调用 `on_cards_played`。
   - 订阅 `EventManager.buff_applied` → 更新内部修正。

### 2.3 验收
- 最小测试场景能跑通“start_new_year → 两学期 → 考核”。
- `player_score` 随打牌更新，UI 监听 `game_state_changed` 正确刷新。

---

## 3. UI 场景流转与信号连接

### 3.1 目标
- 将逻辑信号可视化：学年/学期 HUD、WisdomHall、Assessment 界面。

### 3.2 场景/节点
```
MainGame.tscn
├── HUD (Control)
│   ├── YearLabel
│   ├── TermLabel
│   ├── ScoreLabel
│   └── LoreLabel
├── WisdomHallPanel (Control) [隐藏]
├── AssessmentPanel (Control) [隐藏]
└── CardArea (现有)
```

### 3.3 信号绑定
| 逻辑信号 | HUD 更新 | 界面切换 |
|-----------|---------|---------|
| `new_year_started` | YearLabel | 关闭 WisdomHall / Assessment |
| `term_started` | TermLabel | - |
| `wisdom_hall_opened` | - | 打开 WisdomHallPanel |
| `assessment_started` | - | 打开 AssessmentPanel |
| `game_state_changed` | Score & Lore | - |

### 3.4 实现步骤
1. 在 `MainGame.gd` 中连接所有信号并更新 UI。
2. 使用 `AnimationPlayer` 或简单 `visible = true/false` 做界面切换。
3. 运行一年流程，确保显示同步。

### 3.5 验收
- 点击“下一回合”按钮能正确驱动 `start_term()` 等流程。
- HUD 各字段实时刷新；商店/考核面板按信号出现/关闭。

---

## 4. 时间线与里程碑（示例）
| 日期 | 任务 | 里程碑 |
|------|------|--------|
| D1 | 完成 ScoreCalculator 扩展 & 单元测试 | 分数倍率逻辑通过测试 |
| D2 | GameManager 字段替换 + 流程方法 | 能跑通一年两学期流程 |
| D3 | 信号订阅 + on_cards_played | 得分实时更新 |
| D4 | HUD 场景/脚本完成 | 学年/分数可视化 |
| D5 | WisdomHall & Assessment 面板 | 场景流转完成 |

---

完成以上首批任务后，阶段二剩余部分（EventManager、CardManager 等）可并行推进，最终整合进入完整核心循环。
