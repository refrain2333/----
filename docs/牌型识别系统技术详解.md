# 🎯 奥术学院扑克 - 牌型识别系统技术详解

## 📋 系统概述

奥术学院扑克的牌型识别系统采用**V2.1架构**，实现了完整的扑克牌型识别、得分计算和动态等级管理。系统设计遵循**数据隔离**和**职责分离**原则，将牌型识别与得分计算完全分离，确保高内聚、低耦合的架构设计。

### 🏗️ 核心架构

```
HandTypeSystemV2 (统一接口)
├── SmartHandAnalyzerV2 (牌型识别)
│   └── PokerHandAnalyzer (5张牌分析器)
├── PreciseScoreCalculator (得分计算)
└── HandTypeRankingManager (等级管理)
```

## 🎯 核心组件详解

### 1. HandTypeSystemV2 - 统一接口层

**职责**: 提供统一的牌型识别和得分计算接口

**核心方法**:
```gdscript
# 完整分析接口（牌型识别 + 得分计算）
static func analyze_and_score(cards: Array, ranking_manager = null, bonus_score: int = 0) -> Dictionary

# 仅牌型识别接口
static func analyze_hand_type(cards: Array) -> HandResult

# 仅得分计算接口
static func calculate_score(hand_result: HandResult, ranking_manager = null, bonus_score: int = 0) -> ScoreResult

# 快速得分接口
static func quick_score(cards: Array, level: int = 1, bonus_score: int = 0) -> int
```

**返回结果结构**:
```gdscript
{
    "hand_result": HandResult,      # 牌型识别结果
    "score_result": ScoreResult,    # 得分计算结果
    "total_analysis_time": int,     # 总分析耗时(ms)
    "is_valid": bool               # 结果有效性
}
```

### 2. SmartHandAnalyzerV2 - 智能牌型分析器

**职责**: 智能分析1-N张牌的最佳牌型

**核心算法**:
```gdscript
static func find_best_hand(cards: Array) -> HandResult:
    if cards.size() < 5:
        # 少于5张牌：分析部分手牌
        return _analyze_partial_hand(cards)
    elif cards.size() == 5:
        # 正好5张牌：直接分析
        return PokerHandAnalyzer.analyze(cards)
    else:
        # 超过5张牌：找最佳组合
        return _find_best_combination(cards)
```

**分析策略**:
- **1-4张牌**: 部分手牌分析（对子、三条等）
- **5张牌**: 直接使用PokerHandAnalyzer分析
- **6-10张牌**: 穷举所有5张牌组合
- **11+张牌**: 启发式算法优化性能

### 3. PokerHandAnalyzer - 5张牌专业分析器

**职责**: 专门处理标准5张牌的牌型识别

**支持牌型** (按优先级排序):
1. **五条** (FIVE_KIND) - 5张相同数值
2. **皇家同花顺** (ROYAL_FLUSH) - A-K-Q-J-10同花
3. **同花顺** (STRAIGHT_FLUSH) - 连续5张同花
4. **四条** (FOUR_KIND) - 4张相同数值
5. **葫芦** (FULL_HOUSE) - 三条+一对
6. **同花** (FLUSH) - 5张同花色
7. **顺子** (STRAIGHT) - 连续5张数值
8. **三条** (THREE_KIND) - 3张相同数值
9. **两对** (TWO_PAIR) - 两个对子
10. **一对** (PAIR) - 2张相同数值
11. **高牌** (HIGH_CARD) - 无特殊牌型

**评估器架构**:
```gdscript
var evaluators = [
    {"name": "五条", "evaluator": _evaluate_five_kind},
    {"name": "皇家同花顺", "evaluator": _evaluate_royal_flush},
    {"name": "同花顺", "evaluator": _evaluate_straight_flush},
    # ... 其他评估器
]
```

### 4. PreciseScoreCalculator - 精确得分计算器

**职责**: 基于牌型识别结果计算精确得分

**得分公式**:
```
最终得分 = ROUND((基础分 + 牌面分 + 附加分) × 动态倍率)
```

**得分组成**:
- **基础分**: 牌型固定分值 (HandTypeEnums.BASE_SCORES)
- **牌面分**: 根据牌型和卡牌数值计算
- **附加分**: 外部效果加成
- **动态倍率**: 基于牌型等级的倍率

**牌面分计算规则**:
```gdscript
match hand_type:
    HandType.HIGH_CARD:    # 最高牌价值 × 2
    HandType.PAIR:         # 对子价值 × 4
    HandType.TWO_PAIR:     # 大对子×6 + 小对子×4
    HandType.THREE_KIND:   # 三条价值 × 8
    HandType.STRAIGHT:     # 所有5张牌价值总和
    HandType.FLUSH:        # (所有5张牌价值总和) × 1.2
    HandType.FULL_HOUSE:   # 三条×10 + 对子×6
    HandType.FOUR_KIND:    # 四条价值 × 15
    # ... 其他牌型
```

### 5. HandTypeRankingManager - 动态等级管理器

**职责**: 管理牌型的动态等级系统 (LV1-LV5)

**等级倍率配置**:
```gdscript
const LEVEL_MULTIPLIERS = {
    HandType.HIGH_CARD: [1.0, 0.2],      # 1.0x → 1.8x
    HandType.PAIR: [1.5, 0.3],           # 1.5x → 2.7x
    HandType.TWO_PAIR: [2.0, 0.4],       # 2.0x → 3.6x
    HandType.THREE_KIND: [3.0, 0.6],     # 3.0x → 5.4x
    # ... 其他牌型
}
```

**动态倍率计算**:
```gdscript
动态倍率 = 基础倍率 + (当前等级 - 1) × 等级增量
```

**核心方法**:
```gdscript
# 设置牌型等级
func set_hand_type_level(hand_type: HandType, level: int) -> bool

# 升级牌型等级
func level_up_hand_type(hand_type: HandType) -> bool

# 获取动态倍率
func get_multiplier(hand_type: HandType) -> float
```

## 📊 数据结构详解

### HandResult - 牌型识别结果

```gdscript
class HandResult:
    # 基础牌型信息
    var hand_type: HandType                 # 牌型枚举
    var hand_type_name: String             # 牌型中文名称
    var description: String                # 牌型描述
    
    # 核心牌值（用于计分）
    var primary_value: int = 0             # 主要牌值
    var secondary_value: int = 0           # 次要牌值
    
    # 卡牌组织
    var contributing_cards: Array = []      # 构成牌型的核心卡牌
    var kickers: Array = []                # 踢脚牌数值
    var all_cards: Array = []              # 所有参与分析的卡牌
    
    # 分析元数据
    var combinations_tested: int = 0        # 测试的组合数量
    var analysis_method: String = ""       # 分析方法
```

### ScoreResult - 得分计算结果

```gdscript
class ScoreResult:
    # 最终得分
    var final_score: int = 0               # 最终得分 (取整后)
    var raw_score: float = 0.0             # 原始得分 (取整前)
    
    # 得分组成部分
    var base_score: int = 0                # 基础牌型分
    var value_score: int = 0               # 牌面价值分
    var bonus_score: int = 0               # 附加分
    var total_base: int = 0                # 基础总分
    
    # 倍率信息
    var dynamic_multiplier: float = 1.0    # 动态倍率
    var hand_type_level: int = 1           # 牌型等级
    
    # 计算公式
    var calculation_formula: String = ""    # 简化公式
    var detailed_formula: String = ""       # 详细公式
    var step_by_step: Array = []           # 分步计算过程
    
    # 性能指标
    var calculation_time_ms: int = 0       # 计算耗时
```

## 🎮 使用示例

### 基础牌型识别

```gdscript
# 1. 创建卡牌数组
var cards = [card1, card2, card3, card4, card5]

# 2. 执行牌型识别
var hand_result = HandTypeSystemV2.analyze_hand_type(cards)

# 3. 获取结果
print("牌型: %s" % hand_result.hand_type_name)
print("描述: %s" % hand_result.description)
print("构成卡牌: %d张" % hand_result.contributing_cards.size())
```

### 完整得分计算

```gdscript
# 1. 创建等级管理器
var ranking_manager = HandTypeRankingManager.new()
ranking_manager.set_hand_type_level(HandTypeEnums.HandType.PAIR, 3)  # 设置一对为LV3

# 2. 执行完整分析
var result = HandTypeSystemV2.analyze_and_score(cards, ranking_manager, 10)

# 3. 获取详细结果
print("牌型: %s" % result.hand_result.hand_type_name)
print("最终得分: %d" % result.score_result.final_score)
print("计算公式: %s" % result.score_result.calculation_formula)
print("分析耗时: %dms" % result.total_analysis_time)
```

### 动态等级管理

```gdscript
# 创建等级管理器
var ranking_manager = HandTypeRankingManager.new()

# 设置牌型等级
ranking_manager.set_hand_type_level(HandTypeEnums.HandType.PAIR, 3)
ranking_manager.set_hand_type_level(HandTypeEnums.HandType.THREE_KIND, 2)

# 升级牌型
ranking_manager.level_up_hand_type(HandTypeEnums.HandType.FLUSH)

# 获取等级信息
var level = ranking_manager.get_hand_type_level(HandTypeEnums.HandType.PAIR)
var multiplier = ranking_manager.get_multiplier(HandTypeEnums.HandType.PAIR)
print("一对等级: LV%d, 倍率: %.1fx" % [level, multiplier])
```

## 🔧 性能特性

### 算法复杂度
- **1-5张牌**: O(1) - 直接分析
- **6-10张牌**: O(C(n,5)) - 穷举组合
- **11+张牌**: O(k) - 启发式算法，k << C(n,5)

### 性能优化
- **静态初始化**: 评估器只初始化一次
- **智能组合**: 超过10张牌时使用启发式算法
- **缓存机制**: 重复计算结果可缓存
- **并行处理**: 支持批量分析

### 内存管理
- **RefCounted**: 所有核心类继承RefCounted，自动内存管理
- **数组复制**: 关键数据使用duplicate()避免引用问题
- **临时对象**: 分析过程中的临时对象及时释放

## 🎯 扩展性设计

### 新牌型支持
1. 在`HandTypeEnums`中添加新枚举值
2. 在`PokerHandAnalyzer`中添加对应评估器
3. 在`PreciseScoreCalculator`中添加计分规则
4. 更新`LEVEL_MULTIPLIERS`配置

### 自定义计分规则
```gdscript
# 继承PreciseScoreCalculator实现自定义计分
class CustomScoreCalculator extends PreciseScoreCalculator:
    static func _calculate_value_score(hand_result: HandResult) -> int:
        # 自定义计分逻辑
        return custom_calculation(hand_result)
```

### 插件化评估器
```gdscript
# 注册自定义评估器
PokerHandAnalyzer.register_evaluator("自定义牌型", custom_evaluator_function)
```

## 📈 系统监控

### 性能指标
- **分析耗时**: 每次分析的时间消耗
- **组合测试数**: 测试的卡牌组合数量
- **内存使用**: 分析过程中的内存占用
- **缓存命中率**: 缓存系统的效率

### 调试信息
- **详细公式**: 完整的计分公式和步骤
- **卡牌追踪**: 每张卡牌在分析中的作用
- **算法选择**: 使用的分析算法类型
- **错误处理**: 异常情况的处理记录

## 🔍 具体牌型识别算法

### 五条 (FIVE_KIND)
```gdscript
static func _evaluate_five_kind(card_data: Dictionary) -> HandResult:
    var value_counts = card_data.value_counts
    for value in value_counts:
        if value_counts[value] >= 5:
            var result = HandResult.new()
            result.set_hand_type_info(HandType.FIVE_KIND, "五条", "五条: %s" % _value_to_string(value))
            result.set_core_values(value)
            return result
    return null
```

### 皇家同花顺 (ROYAL_FLUSH)
```gdscript
static func _evaluate_royal_flush(card_data: Dictionary) -> HandResult:
    var suits = card_data.suits
    var values = card_data.values

    # 检查是否有A-K-Q-J-10同花
    var royal_values = [14, 13, 12, 11, 10]  # A, K, Q, J, 10

    for suit in suits:
        if suits[suit].size() >= 5:
            var suit_values = suits[suit]
            var has_royal = true
            for royal_val in royal_values:
                if not suit_values.has(royal_val):
                    has_royal = false
                    break

            if has_royal:
                var result = HandResult.new()
                result.set_hand_type_info(HandType.ROYAL_FLUSH, "皇家同花顺", "皇家同花顺: %s" % _suit_to_string(suit))
                result.set_core_values(14)  # A为最高牌
                return result
    return null
```

### 同花顺 (STRAIGHT_FLUSH)
```gdscript
static func _evaluate_straight_flush(card_data: Dictionary) -> HandResult:
    var suits = card_data.suits

    for suit in suits:
        if suits[suit].size() >= 5:
            var suit_values = suits[suit]
            suit_values.sort()

            var straight_info = _find_straight_in_values(suit_values)
            if straight_info.is_straight:
                var result = HandResult.new()
                result.set_hand_type_info(HandType.STRAIGHT_FLUSH, "同花顺",
                    "同花顺: %s %s" % [_value_to_string(straight_info.high_card), _suit_to_string(suit)])
                result.set_core_values(straight_info.high_card)
                return result
    return null
```

### 四条 (FOUR_KIND)
```gdscript
static func _evaluate_four_kind(card_data: Dictionary) -> HandResult:
    var value_counts = card_data.value_counts
    var values = card_data.values

    for value in value_counts:
        if value_counts[value] >= 4:
            # 找到踢脚牌
            var kickers = []
            for v in values:
                if v != value and kickers.size() < 1:
                    kickers.append(v)

            var result = HandResult.new()
            result.set_hand_type_info(HandType.FOUR_KIND, "四条", "四条: %s" % _value_to_string(value))
            result.set_core_values(value)
            result.kickers = kickers
            return result
    return null
```

### 葫芦 (FULL_HOUSE)
```gdscript
static func _evaluate_full_house(card_data: Dictionary) -> HandResult:
    var value_counts = card_data.value_counts
    var three_kind_value = -1
    var pair_value = -1

    # 找三条
    for value in value_counts:
        if value_counts[value] >= 3:
            three_kind_value = value
            break

    # 找对子（不能与三条相同）
    for value in value_counts:
        if value != three_kind_value and value_counts[value] >= 2:
            pair_value = value
            break

    if three_kind_value != -1 and pair_value != -1:
        var result = HandResult.new()
        result.set_hand_type_info(HandType.FULL_HOUSE, "葫芦",
            "葫芦: %s带%s" % [_value_to_string(three_kind_value), _value_to_string(pair_value)])
        result.set_core_values(three_kind_value, pair_value)
        return result

    return null
```

## ⚠️ 错误处理机制

### 输入验证
```gdscript
# 卡牌数量检查
if cards.is_empty():
    return HandResult.create_empty()

# 卡牌数据完整性检查
for card in cards:
    if not card or not card.has_method("get"):
        push_error("无效的卡牌数据")
        return HandResult.create_empty()
```

### 异常情况处理
```gdscript
# 超大数据集保护
if cards.size() > 20:
    push_warning("卡牌数量过多(%d张)，使用启发式算法" % cards.size())
    return _find_best_combination_heuristic(cards)

# 内存保护
if combinations_count > 10000:
    push_warning("组合数量过多，限制分析范围")
    return _limited_analysis(cards)
```

### 性能监控
```gdscript
# 分析时间监控
var start_time = Time.get_ticks_msec()
var result = _perform_analysis(cards)
var analysis_time = Time.get_ticks_msec() - start_time

if analysis_time > 100:  # 超过100ms
    push_warning("牌型分析耗时过长: %dms" % analysis_time)
```

## 🧪 测试框架

### 单元测试
```gdscript
# 测试特定牌型识别
func test_pair_recognition():
    var cards = [create_card("S", 7), create_card("H", 7), create_card("D", 3),
                 create_card("C", 9), create_card("S", 2)]
    var result = HandTypeSystemV2.analyze_hand_type(cards)
    assert(result.hand_type == HandTypeEnums.HandType.PAIR)
    assert(result.primary_value == 7)
```

### 性能测试
```gdscript
# 批量性能测试
func performance_test_batch():
    var test_cases = generate_random_hands(1000)
    var start_time = Time.get_ticks_msec()

    for cards in test_cases:
        HandTypeSystemV2.analyze_hand_type(cards)

    var total_time = Time.get_ticks_msec() - start_time
    print("批量测试耗时: %dms, 平均: %.2fms/手" % [total_time, float(total_time) / 1000])
```

### 边界测试
```gdscript
# 边界条件测试
func test_edge_cases():
    # 空数组
    var empty_result = HandTypeSystemV2.analyze_hand_type([])
    assert(not empty_result.is_valid())

    # 单张牌
    var single_card = [create_card("S", 14)]
    var single_result = HandTypeSystemV2.analyze_hand_type(single_card)
    assert(single_result.hand_type == HandTypeEnums.HandType.HIGH_CARD)

    # 大量卡牌
    var many_cards = generate_cards(15)
    var many_result = HandTypeSystemV2.analyze_hand_type(many_cards)
    assert(many_result.is_valid())
```

## 📚 配置文件

### 基础分值配置
```gdscript
# HandTypeEnums.gd
const BASE_SCORES = {
    HandType.HIGH_CARD: 1,
    HandType.PAIR: 2,
    HandType.TWO_PAIR: 3,
    HandType.THREE_KIND: 5,
    HandType.STRAIGHT: 8,
    HandType.FLUSH: 13,
    HandType.FULL_HOUSE: 21,
    HandType.FOUR_KIND: 34,
    HandType.STRAIGHT_FLUSH: 55,
    HandType.ROYAL_FLUSH: 89,
    HandType.FIVE_KIND: 144
}
```

### 等级倍率配置
```gdscript
# 动态倍率配置 [基础倍率, 每级增量]
const LEVEL_MULTIPLIERS = {
    HandType.HIGH_CARD: [1.0, 0.2],      # LV1: 1.0x → LV5: 1.8x
    HandType.PAIR: [1.5, 0.3],           # LV1: 1.5x → LV5: 2.7x
    HandType.TWO_PAIR: [2.0, 0.4],       # LV1: 2.0x → LV5: 3.6x
    HandType.THREE_KIND: [3.0, 0.6],     # LV1: 3.0x → LV5: 5.4x
    HandType.STRAIGHT: [4.0, 0.8],       # LV1: 4.0x → LV5: 7.2x
    HandType.FLUSH: [5.0, 1.0],          # LV1: 5.0x → LV5: 9.0x
    HandType.FULL_HOUSE: [7.0, 1.4],     # LV1: 7.0x → LV5: 12.6x
    HandType.FOUR_KIND: [10.0, 2.0],     # LV1: 10.0x → LV5: 18.0x
    HandType.STRAIGHT_FLUSH: [15.0, 3.0], # LV1: 15.0x → LV5: 27.0x
    HandType.ROYAL_FLUSH: [25.0, 5.0],   # LV1: 25.0x → LV5: 45.0x
    HandType.FIVE_KIND: [50.0, 10.0]     # LV1: 50.0x → LV5: 90.0x
}
```

## 🔮 未来扩展

### 计划功能
1. **AI辅助分析**: 机器学习优化牌型识别准确性
2. **并行处理**: 多线程处理大量卡牌组合
3. **缓存系统**: 智能缓存常见牌型组合
4. **统计分析**: 牌型出现频率和概率分析
5. **自定义规则**: 支持用户自定义牌型和计分规则

### 性能优化
1. **预计算表**: 预计算常见组合的结果
2. **位运算优化**: 使用位运算加速花色和数值检查
3. **内存池**: 复用临时对象减少GC压力
4. **SIMD指令**: 利用SIMD指令并行处理数据

---

*本文档基于奥术学院扑克V2.1牌型识别系统，详细描述了系统的架构设计、核心算法、数据结构、错误处理、测试框架和配置管理。系统采用模块化设计，支持灵活扩展和自定义配置。*
