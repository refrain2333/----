# 奥术学院扑克——分阶段实现指南 (v1.6)

## 开发原则

- **垂直切片**：每个阶段实现一个从数据到UI的完整小功能点。
- **依赖先行**：先实现被依赖的基础模块和数据结构。
- **信号为王**：优先使用Godot信号进行模块间通信，减少直接引用。
- **数据驱动**：所有游戏内容通过资源文件管理，便于迭代和平衡。
- **单例职责**：确保每个单例只做它应该做的事。

------

## 阶段一：基础数据与强化视觉

**目标**：构建所有核心数据结构为Godot `Resource`，并实现卡牌强化效果的视觉显示。这将为后续所有功能提供数据骨架。

1. **文件结构准备**

   - 在 `cs/` 下新增 `Global/` 文件夹。
   - 在 `assets/` 下新增 `data/` 文件夹，并在其中创建 `cards/`, `artifacts/`, `spells/`, `jokers/` 子文件夹。
   - 在 `assets/images/` 下新增 `icons/abilities/` (用于法器、法术、守护灵图标) 和 `icons/card_reinforcements/` (用于蜡封、牌框、材质图标)。

2. **核心数据资源定义**

   - `cs/Global/GlobalEnums.gd` (新建GDScript文件)

     - **内容**：定义GDD中所有提到的枚举（Rarity, TermType, CardReinforcementType, WaxSealType, FrameType, MaterialType, EffectTriggerTiming, SpellType），以及所有牌型的字符串常量。
     - **集成**：设置为**自动加载 (Autoload)**，名称如 `GlobalEnums`。
     - **测试**：确保其他脚本可以访问 `GlobalEnums.Rarity.COMMON` 等。

   - `cs/Global/GameConfig.gd` (新建GDScript Resource)

     - **内容**：GDD中所有游戏配置常量，如 `victory_scores`, `term_rewards`, `initial_hand_size` 等。
     - **实现**：继承 `Resource`，并添加 `@export` 变量。
     - **集成**：在 `assets/data/` 下创建 `GameConfig.tres` 实例，在 `GameManager` 中通过 `preload("res://assets/data/game_config.tres")` 引用。
     - **测试**：在 `_ready()` 中 `print(GameManager.game_config.victory_scores)` 验证加载。

   - `cs/主场景/abilities/ArtifactData.gd`, `SpellData.gd`, `JokerData.gd` (新建GDScript Resource)

     - **内容**：根据GDD 6.1, 6.2, 6.3 字段定义，继承 `Resource`。每个资源应包含 `id` (字符串), `name`, `description`, `rarity`, `cost`, `effect_type` (字符串，表示效果类型，如 "ADD_XP_PER_PAIR"), `effect_value` (Variant)。
     - **`SpellData.gd` 特殊**：新增 `spell_type` (`GlobalEnums.SpellType`), `charges` (int) 字段。
     - **集成**：在 `assets/data/artifacts/`, `spells/`, `jokers/` 目录下创建所有对应的 `.tres` 文件实例。
     - **测试**：编写一个临时脚本，尝试加载并打印这些资源实例的属性。

   - `cs/主场景/card/CardData.gd` (重构为GDScript Resource)

     - **内容**：已有的 `name`, `suit`, `value`, `image_path` 字段，新增 `id` (字符串), `wax_seals` (Array[String]), `frame_type` (String), `material_type` (String)。

     - 方法

       ：

       - `func add_reinforcement(type: String, effect: String)`: 添加强化。
       - `func remove_wax_seal(seal_type: String)`: 移除蜡封。
       - `func clone() -> CardData`: **关键方法**，深拷贝 `CardData` 实例，为复制牌机制做准备。

     - **集成**：将所有52张扑克牌数据转换为 `CardData.tres` 文件，放在 `assets/data/cards/`。

     - **测试**：验证 `CardData.clone()` 是否能创建独立的副本。

3. **卡牌视图强化显示 (`cs/主场景/card/CardView.gd` 和 `CardView.tscn`)**

   - **职责**：根据 `CardData` 中的强化信息，动态显示视觉效果。

   - `CardView.tscn` 修改

     ：

     - 在根节点下，添加一个 `Node2D` (或 `Control`) 作为 `ReinforcementContainer`。
     - 在 `ReinforcementContainer` 中，添加子节点用于显示蜡封、牌框、材质。例如：`TextureRect` (for frame), `Node2D` (for wax seal icons), `CanvasModulate` (for material effects like glass transparency).

   - `CardView.gd` 修改

     ：

     - ```
       set_card_data(data: CardData)
       ```

       :

       - 调用 `_update_reinforcement_visuals()` 方法。

     - ```
       _update_reinforcement_visuals()
       ```

        

       (新方法):

       - 根据 `data.frame_type` 设置牌框 `TextureRect` 的纹理。
       - 根据 `data.material_type` 调整 `CanvasModulate` 的颜色/透明度或加载特效。
       - 遍历 `data.wax_seals` 数组，为每个蜡封动态创建 `TextureRect` (或 `Sprite2D`) 并添加到 `ReinforcementContainer`。
       - 清除旧的强化视觉元素，防止堆叠。

     - `_on_card_clicked()`: 除了现有逻辑，现在传入的是完整的 `CardView` 实例，以便 `HandDock` 可以获取 `CardData`。

   - **测试**：手动修改几张 `CardData.tres` 文件的强化字段，运行游戏，验证 `CardView` 是否正确显示了强化效果。

------

## 阶段二：核心游戏循环与玩家状态

**目标**：实现完整的学年-学期-研习-商店-考核流程，并管理玩家的能力（法器、法术、守护灵）和牌型等级。

1. **游戏管理器核心逻辑 (`cs/Global/GameManager.gd`)**

   - **职责**：**全局核心单例**。管理整个游戏的状态流程，玩家所有能力列表、牌型等级。

   - **字段**：按照GDD 2.1 节添加所有字段 (`current_year`, `current_term`, `player_score`, `lore_points`, `artifact_slots`, `spell_bag_capacity`, `joker_slots`, `equipped_artifacts`, `spell_inventory`, `active_jokers`, `card_type_levels`, `player_hand_size_modifier`, `current_assessment_score`).

   - 在 `_ready()` 中

     ：

     - `game_config = preload("res://assets/data/game_config.tres")`
     - 初始化 `card_type_levels` 字典，所有牌型LV1。

   - 核心流程方法

     ：

     - `initialize_game_state()`: 重置所有上述字段到初始值。清空所有能力数组。
     - `start_new_year(year: int)`: 更新 `current_year`，应用学年限制/增益（这些限制/增益将在 `EventManager` 中管理），发出 `new_year_started` 信号。
     - `start_term(term: GlobalEnums.TermType)`: 更新 `current_term`，发出 `term_started` 信号。
     - `end_term()`: **发出 `term_ended` 信号**。
     - `start_wisdom_hall()`: 发出 `wisdom_hall_opened` 信号。
     - `start_assessment()`: 重置 `current_assessment_score`，发出 `assessment_started` 信号。
     - `game_won()` / `game_lost()`: 触发游戏结束流程，发出信号。

   - 玩家能力管理方法

     ：

     - `add_lore(amount: int)`: 增加 `lore_points`，并考虑**魔力水晶法器加成**（通过 `get_active_effect_modifier()` 获取），发出 `lore_changed` 信号。
     - `add_artifact(artifact: ArtifactData)`: 检查 `artifact_slots`，添加法器到 `equipped_artifacts`，发出 `player_abilities_changed`。
     - `add_spell(spell: SpellData)`: 检查 `spell_bag_capacity`。如果 `spell_inventory` 中已有同ID法术，则增加其 `charges`；否则添加新法术实例。发出 `player_abilities_changed`。
     - `use_active_spell(spell_data: SpellData, target_cards: Array[CardData] = [])`: 减少 `spell_data.charges`。**调用 `trigger_effect_logic()` 处理法术具体效果**。发出 `player_abilities_changed` 和 `spell_used` 信号。
     - `activate_joker(joker: JokerData, old_joker_index: int = -1)`: 处理守护灵激活/替换逻辑。添加到 `active_jokers`，发出 `player_abilities_changed`。

   - 状态查询方法

     ：

     - `get_current_hand_size() -> int`: 计算当前实际手牌上限 (基础 + `player_hand_size_modifier` + `EventManager` 的影响)。
     - `get_card_type_level(type_name: String) -> int`: 获取牌型等级。
     - `modify_card_type_level(type_name: String, amount: int)`: 提升牌型等级，限制在LV5，发出 `card_type_levels_changed`。

   - 效果调度接口 (`trigger_effect_logic` 是核心)

     ：

     - `get_active_effect_modifier(effect_key: String) -> Variant`: **关键通用方法**。遍历 `equipped_artifacts`, `active_jokers` 和 `EventManager` 的 Buff/Debuff。根据 `effect_type` 收集并返回对 `effect_key` (如"total_xp_percent_bonus", "hand_size_modifier") 的累积修改量。这个方法会被 `ScoreCalculator` 和其他模块广泛调用。

     - ```
       trigger_effect_logic(effect_data: Dictionary, trigger_params: Dictionary = {})
       ```

       :

        

       通用效果处理器

       。根据传入的

        

       ```
       effect_data
       ```

        

       (结构如

        

       ```
       {"type": "ADD_LORE", "value": 10}
       ```

       )，执行具体的游戏逻辑。这会将法器、法术、守护灵的抽象效果类型映射到实际代码。

       - 例如：如果 `effect_data.type == "ADD_LORE"`, 调用 `add_lore(effect_data.value)`.
       - 如果 `effect_data.type == "MODIFY_CARD_TYPE_LEVEL"`, 调用 `modify_card_type_level(effect_data.target_type, effect_data.amount)`.
       - 如果 `effect_data.type == "ADD_CARD_REINFORCEMENT"`, 则需要传入 `target_card_id` 参数，然后调用 `CardManager.add_reinforcement_to_card_in_hand()`. (这会涉及到 `CardManager` 的新方法)

   - 信号

     ：

     - `game_state_changed`: (year, term, player_score, lore_points)
     - `player_abilities_changed`: (artifacts, spells, jokers)
     - `card_type_levels_changed`: (card_type_levels)
     - `new_year_started(year_num)`
     - `term_started(term_type)`
     - `term_ended()`
     - `wisdom_hall_opened()`
     - `assessment_started(year_num)`
     - `game_won()`
     - `game_lost()`
     - `lore_changed(new_lore_points)`
     - `spell_used(spell_id)`

2. **事件管理器 (`cs/Global/EventManager.gd`)**

   - **职责**：管理随机事件和临时Buff/Debuff。

   - **字段**：`active_term_buffs`, `active_turn_buffs`, `active_debuffs`, `arcane_intuition_perfect_score`, `is_arcane_intuition_active`。

   - 主要方法

     ：

     - `_ready()`: 确保是单例。

     - `add_term_buff(buff_data: Dictionary)`: 添加学年Buff，在 `GameManager` 的 `start_new_year` 信号中清除。

     - `add_turn_buff(buff_data: Dictionary)`: 添加回合Buff，在 `GameManager` 的回合结束时调用 `EventManager.clear_turn_buffs()`。

     - `apply_debuff(debuff_data: Dictionary)`: 添加Debuff，其 `duration` 在 `_on_turn_ended_in_study` 中减少，到0移除。

     - `get_modifier(effect_key: String) -> Variant`: 返回所有活跃Buff/Debuff对某个效果的累积修改量（例如，手牌上限修正、基础分修正）。

     - `trigger_random_event(current_year: int)`: 根据学年和概率，随机触发一个事件（如奥术直觉考验，或临时Debuff）。

     - ```
       trigger_arcane_intuition_test(player_hand: Array[CardData], game_manager_state_snapshot: Dictionary)
       ```

       :

       - 调用 `ScoreCalculator.calculate_perfect_score()` 计算最优解。
       - 设置 `is_arcane_intuition_active = true`。
       - 发出 `arcane_intuition_started` 信号。

     - `check_arcane_intuition_result(player_actual_score: int)`: 比较并给予奖励，重置状态，发出 `arcane_intuition_finished` 信号。

     - `clear_turn_buffs()`: 清除回合Buff。

     - `clear_term_buffs()`: 清除学年Buff。

   - **信号**：`arcane_intuition_started()`, `arcane_intuition_finished(succeeded: bool)`, `buff_applied(buff_data)`, `debuff_applied(debuff_data)`, `random_event_triggered(event_id, event_description)`.

### **阶段三：高级卡牌操作与分数计算**

**目标**：实现牌库的增删改查，完善卡牌强化效果的触发和分数计算逻辑。

1. **卡牌管理器 (`cs/主场景/card/CardManager.gd`)**

   - **职责**：专注于牌库、弃牌堆、手牌的牌张管理和操作，以及打牌/弃牌的具体流程。

   - **字段**：`deck: Array[CardData]`, `discard_pile: Array[CardData]`, `hand: Array[CardData]`, `destroyed_pile: Array[CardData]`.

   - 主要方法

     ：

     - `initialize_rune_library(base_card_resources: Array[Resource])`: 初始加载所有52张基础 `CardData` Resource，并`clone()`它们的实例，填充 `deck`。

     - `draw_rune(count: int) -> Array[CardData]`: 从 `deck` 抽牌，若 `deck` 空则洗 `discard_pile` 回 `deck`。

     - `add_card_to_deck(card: CardData, shuffle: bool = true)`: 增加牌到牌库。

     - `remove_card_from_deck(card_id: String)`: 永久移除牌（移入 `destroyed_pile`）。

     - `copy_card_to_deck(original_card_id: String)`: 找到原牌，`clone()` 并加入牌库。

     - `_move_card(card: CardData, from_pile: Array, to_pile: Array)`: 内部辅助方法，执行实际的牌堆移动。

     - ```
       play_selected_cards(selected_cards_data: Array[CardData])
       ```

       :

       - 验证选中的5张牌是否符合学年限制（通过 `GameManager.get_active_effect_modifier()` 获取学年限制）。
       - **高内聚点**：调用 `ScoreCalculator.calculate_score(selected_cards_data, GameManager)` 获取得分。
       - 将得分传递给 `GameManager.add_player_score_for_assessment()` (冬季考核) 和 `GameManager.add_lore()`。
       - **强化触发**：遍历 `selected_cards_data`，触发蜡封效果 (`card.remove_wax_seal()`)，并调用 `GameManager.trigger_effect_logic()` 执行蜡封的具体效果。
       - **材质效果**：根据 `card.material_type` 判断玻璃材质销毁几率（检查是否有银质牌框），岩石材质回牌库底部。
       - 将牌从 `hand` 移动到 `discard_pile` 或 `destroyed_pile`。
       - 发出 `score_changed`, `hand_changed`, `deck_changed`, `cards_played` 信号。

     - ```
       discard_selected_cards(selected_cards_data: Array[CardData])
       ```

       :

       - 触发相关法器/守护灵的“弃牌时”效果 (`GameManager.trigger_effect_logic()` 调度)。
       - 根据材质效果处理牌的归属。
       - 将牌从 `hand` 移动到 `discard_pile`。
       - 发出 `hand_changed`, `deck_changed` 信号。

     - `add_reinforcement_to_card_in_hand(card_id: String, type: String, effect: String)`: 找到手牌中的对应 `CardData` 实例，调用 `card.add_reinforcement()`。

     - `get_deck_composition_info() -> Dictionary`: 返回牌库、弃牌堆、销毁堆的 `CardData` 数组副本，供 `DeckBrowserUI` 显示。

   - 信号

     ：

     - `hand_changed(current_hand: Array[CardData])`
     - `deck_changed(deck_size, discard_size, destroyed_size)`
     - `cards_played(played_cards: Array[CardData])` - 用于触发相关效果

2. **分数计算器 (`cs/Global/ScoreCalculator.gd`)**

   - **职责**：**纯函数式单例**。只负责根据输入数据（玩家手牌、`GameManager` 实例），纯粹地**计算**最终得分，不修改任何游戏状态。

   - 方法

     ：

     ```
     class_name ScoreCalculator extends Node
     
     @onready var game_config: GameConfig = preload("res://assets/data/game_config.tres")
     
     func calculate_score(
         played_cards: Array[CardData], 
         game_manager: GameManager # 传入 GameManager 实例来获取所有状态和能力
     ) -> int:
         var current_score = 0
         var temp_played_cards = played_cards.duplicate(true) # 深拷贝，避免修改原始牌数据
     
         # Step 1: 牌型识别与点数修正
         # - 遍历 temp_played_cards，为每张牌获取其修正后的点数 (card.get_modified_value(game_manager))
         # - 实现扑克牌型识别算法，找到最高牌型 (识别出牌型字符串，如 "Pair", "Flush")
         # - 处理牌型转化 (例如，双子法典：若识别为"TwoPair"，但有法典，则视为"FullHouse")
         # - 处理金色蜡封复制 (若有金色蜡封无效果牌，则在识别时逻辑上视为两张牌)
         var recognized_card_type: String = "HighCard" # 实际识别出的牌型
         var temp_base_score_pre_multiply: int = 0
     
         # Step 2: 获取基础学识点与直接加成
         temp_base_score_pre_multiply = game_config.card_type_base_scores.get(recognized_card_type, 0)
         # - 学年增益/限制: temp_base_score_pre_multiply += game_manager.get_active_effect_modifier("year_base_score_bonus")
         # - 紫色蜡封: 遍历 temp_played_cards，若有紫色蜡封，temp_base_score_pre_multiply += 20
         # - 瞬发法术“灵光一闪”: 若 GameManager 标记本回合使用过，temp_base_score_pre_multiply *= 2
         # - 贤者之石: 若 GameManager 标记本回合第一次打牌且有贤者之石，temp_base_score_pre_multiply += 15
         # - 魔力灌注 (跳过Buff): 若 EventManager 标记有此Buff，temp_base_score_pre_multiply += 20
         # - 瞬发法术“奥术激发”: 若 GameManager 标记本回合使用过且匹配牌型，temp_base_score_pre_multiply += 10
         # - 守护灵“秩序维护者”: 若有，且牌型符合，temp_base_score_pre_multiply += 10
         # - 守护灵“虚空吞噬者”: 若有，且打出玻璃材质牌，temp_base_score_pre_multiply += 30
     
         # Step 3: 应用牌型等级倍率
         var current_type_level = game_manager.get_card_type_level(recognized_card_type)
         # - 秘法爆发: 若 GameManager 标记本回合使用过，current_type_level = 5
         var level_multiplier = game_config.card_type_level_multipliers.get(recognized_card_type, [])[current_type_level - 1]
         current_score = temp_base_score_pre_multiply * level_multiplier
     
         # Step 4: 应用最终百分比倍率
         var cumulative_percent_bonus_sum = game_manager.get_active_effect_modifier("total_xp_percent_bonus_sum") # 累加型百分比
         var final_multiplicative_factor = game_manager.get_active_effect_modifier("final_xp_multiplicative_factor") # 连乘型百分比 (默认1.0)
         # - 黄金牌框: 遍历 temp_played_cards，若有黄金牌框，final_multiplicative_factor *= 1.5
         # - 连锁反应者: 若有，且打出的牌中强化牌数量满足条件，final_multiplicative_factor *= 1.25
     
         current_score *= (1.0 + cumulative_percent_bonus_sum) * final_multiplicative_factor
     
         # Step 5: 应用额外固定学识点
         # - 学徒笔记: 若牌型为"Pair"，final_score += 3
         # - 符文精粹: 若打出带有石质牌框的牌，final_score += 5
         # - 红色蜡封: 遍历 temp_played_cards，若有红色蜡封，final_score += 10
         # - 符文描拓板: 若有，且本回合第一次打出强化卡牌，final_score += 2
         # - 守护灵“丰饶之手”: 若有，且牌点总和满足，final_score += 20
         # - 守护灵“赌徒之魂”: 若有，且得分满足历史最高分，final_score += 50 (注意这个需要 GameManager 传递历史最高分)
         # - 守护灵“镜像使者”: 若有，且牌型/花色条件满足，final_score += 15
         # - 守护灵“秘藏守卫”: 若有，且法术背包满载，final_score += 10
     
         return round(current_score)
     
     func calculate_perfect_score(
         player_hand_cards: Array[CardData], 
         game_manager: GameManager # 传入 GameManager 实例获取当前所有能力状态
     ) -> int:
         var max_score = 0
         var all_card_combinations = _get_combinations(player_hand_cards, 5) # 获取所有5张牌组合
     
         # 模拟所有瞬发法术使用情况 (这部分是核心难点，需要递归或迭代实现)
         # 对于每个组合，以及每种法术使用情况，调用 calculate_score()
         # 注意：在模拟 calculate_score 时，需要传入一个 GameManager 状态的"快照"或模拟版本，避免真实修改状态。
         # 或者，calculate_score 方法本身设计为无副作用，只读 GameManager 状态。
         
         # 简化版思路：仅考虑不使用瞬发法术的最高分
         for combo in all_card_combinations:
             var score = calculate_score(combo, game_manager)
             if score > max_score:
                 max_score = score
         
         # 更复杂的版本需要考虑法术对牌的点数、花色、强化进行临时修改，并计算所有可能法术链后的最高分。
         # 这是一个典型的回溯/动态规划问题，需要仔细设计状态和剪枝。
         
         return max_score
     
     func _get_combinations(arr: Array, k: int) -> Array: # 辅助函数，获取数组中 k 个元素的组合
         # 实现组合算法
         return []
     ```

   - **低耦合点**：`ScoreCalculator` 接收 `GameManager` 作为参数，但只调用 `GameManager` 的 **查询方法 (`get_active_effect_modifier`, `get_card_type_level` 等)**，不直接访问其内部字段或修改状态。

### **阶段四：UI与交互**

**目标**：构建所有UI场景，并使它们与管理模块进行双向交互。

1. **侧边栏 (`cs/主场景/ui/Sidebar.gd`)**

   - **职责**：显示所有与玩家状态相关的UI信息。

   - 方法

     ：

     - **连接 `GameManager` 的信号**：`_on_game_state_changed`, `_on_player_abilities_changed`, `_on_card_type_levels_changed`。
     - **连接 `CardManager` 的信号**：`_on_deck_changed`。
     - `update_all_displays()`: 根据最新的状态数据，更新学年、学期、学识点、法器/法术/守护灵槽位、牌型等级表、当前学年限制/增益（从 `GameManager` 获取）等所有UI元素。

   - **UI元素**：确保 `Sidebar.tscn` 包含所有需要显示的 `Label`, `TextureRect` (用于图标)，`GridContainer` (用于动态显示牌型等级表)。

2. **手牌区域 (`cs/主场景/ui/HandDock.gd`)**

   - **职责**：管理手牌的显示和用户选择，以及打牌/弃牌/使用法术按钮的交互。

   - **字段**：`selected_cards_data: Array[CardData]`, `selected_spell_data: SpellData`。

   - 方法

     ：

     - `_on_hand_changed(current_hand: Array[CardData])`: 接收 `CardManager` 信号，动态添加/移除 `CardView` 实例，根据 `GameManager.get_current_hand_size()` 调整手牌排列。

     - `_on_player_abilities_changed()`: 接收 `GameManager` 信号，更新**法术背包UI**（显示 `GameManager.spell_inventory` 中的法术，每个法术用一个可点击的按钮或自定义控件表示，显示 `charges` 数量）。

     - `_on_card_clicked(card_view: CardView)`: 切换卡牌选中状态，更新 `selected_cards_data`。

     - `_on_spell_button_pressed(spell_id: String)`: 从 `GameManager.spell_inventory` 找到 `SpellData` 实例。调用 `GameManager.use_active_spell(spell_data, selected_cards_data)`。

     - ```
       _on_play_button_pressed()
       ```

       :

       - 获取 `selected_cards_data` 数组。
       - 验证选牌数量是否为5，并符合学年限制。
       - **发出 `play_cards_requested(selected_cards_data)` 信号** (由 `MainGame` 监听并转发给 `CardManager`)。
       - 清除选中状态。

     - `_on_discard_button_pressed()`: 类似出牌逻辑，**发出 `discard_cards_requested(selected_cards_data)` 信号**。

     - `_update_button_states()`: 根据 `selected_cards_data.size()`, `selected_spell_data`, `GameManager.current_year` 的限制，更新出牌/弃牌/法术按钮的 `disabled` 状态。

   - **信号**：`play_cards_requested(cards: Array[CardData])`, `discard_cards_requested(cards: Array[CardData])`。

3. **牌库浏览器 (`cs/主场景/ui/DeckBrowserUI.tscn` / `cs/主场景/ui/DeckBrowser.gd`) (新)**

   - **职责**：可视化玩家的牌库、弃牌堆、销毁区。

   - **实现**：独立的 `Control` 场景，包含多个 `ScrollContainer` 和 `GridContainer`。

   - `DeckBrowser.gd` 方法

     ：

     - ```
       open_browser()
       ```

       :

       - 调用 `CardManager.get_deck_composition_info()` 获取所有牌堆的 `CardData` 数组副本。
       - 为每张牌创建 `CardView` 实例并添加到对应的 `GridContainer`。

     - `_on_deck_changed()`: 接收 `CardManager` 信号，如果浏览器打开，则刷新内容。

     - `_on_close_button_pressed()`: 隐藏自身。

   - **监听信号**：`CardManager.deck_changed`。

4. **智慧殿堂 (`cs/主场景/ui/WisdomHallUI.tscn` / `cs/主场景/ui/WisdomHallManager.gd`) (新)**

   - **职责**：管理商店逻辑和UI。

   - **实现**：独立的 `Control` 场景。

   - **`WisdomHallManager.gd` 字段**：`current_shop_offers: Array[Resource]`, `shop_item_scenes: Array[PackedScene]` (预制好的商品显示卡牌或按钮场景)。

   - `WisdomHallManager.gd` 方法

     ：

     - `_ready()`: 监听 `GameManager.wisdom_hall_opened` 信号。

     - `on_wisdom_hall_opened()`: 调用 `refresh_shop_offers()`。

     - ```
       refresh_shop_offers()
       ```

       :

       - 根据 `GameConfig` 的稀有度概率和 `GameManager.current_year`，随机生成5个商品实例（`ArtifactData`/`SpellData`/`JokerData`）。
       - 存储在 `current_shop_offers`。
       - 更新UI显示：为每个商品创建一个UI元素，显示名称、描述、费用、稀有度，并连接购买按钮。

     - ```
       _on_buy_button_pressed(item_data: Resource)
       ```

       :

       - 验证 `GameManager.lore_points` 是否足够。
       - 从 `GameManager` 扣除 `lore_points`。
       - 调用 `GameManager.add_artifact()`, `add_spell()`, 或 `activate_joker()`。
       - 移除已购买的商品UI。
       - 更新UI（学识点、能力槽位）。

     - `_on_exit_button_pressed()`: **发出 `wisdom_hall_closed` 信号** (通知 `MainGame` 切换回研习/考核)。

   - **信号**：`wisdom_hall_closed()`.

   - **监听信号**：`GameManager.wisdom_hall_opened`, `GameManager.lore_changed`, `GameManager.player_abilities_changed`。

5. **冬季考核UI (`cs/主场景/ui/AssessmentUI.tscn` / `cs/主场景/ui/AssessmentManager.gd`) (新)**

   - **职责**：管理冬季考核流程和UI。

   - **实现**：可以复用大部分 `MainGame` 的研习UI布局，但有独立的考核UI元素。

   - **`AssessmentManager.gd` 字段**：`target_score: int`, `current_assessment_rounds: int`, `current_assessment_total_score: int`。

   - `AssessmentManager.gd` 方法

     ：

     - `_ready()`: 监听 `GameManager.assessment_started` 信号。

     - `on_assessment_started(year_num)`: 获取 `GameConfig.victory_scores[year_num]` 作为 `target_score`，初始化 `current_assessment_rounds`。更新UI。

     - ```
       _on_cards_played_in_assessment(score: int)
       ```

       : (监听

        

       ```
       CardManager
       ```

        

       信号)

       - `current_assessment_total_score += score`。
       - `current_assessment_rounds--`。
       - 更新UI (`assessment_score_updated` 信号)。
       - 判断是否达到 `target_score` 或回合数用尽。
       - 如果未达标，调用 `GameManager.game_lost()`。
       - 如果达标，调用 `GameManager.game_won()`。

   - **信号**：`assessment_score_updated(current_score, target_score)`。

   - **监听信号**：`GameManager.assessment_started`, `GameManager.game_state_changed`。

6. **学期奖励弹窗 (`cs/主场景/ui/TermRewardUI.tscn` / `cs/主场景/ui/TermRewardManager.gd`) (新)**

   - **职责**：显示学期结束奖励，并应用奖励。

   - **实现**：独立的弹窗场景。

   - `TermRewardManager.gd` 方法

     ：

     - `_ready()`: 监听 `GameManager.term_ended` 信号。
     - `on_term_ended()`: 获取 `GameConfig.term_rewards[GameManager.current_term]`。
     - 根据奖励类型，调用 `GameManager.add_lore()`, `CardManager.add_card_to_deck()` 等。
     - 显示奖励UI，等待玩家点击确认。
     - `_on_confirm_button_pressed()`: 隐藏弹窗，发出 `rewards_claimed` 信号。

   - **信号**：`rewards_claimed()`.

7. **事件弹窗 (`cs/主场景/ui/EventPopup.tscn` / `cs/主场景/ui/EventPopup.gd`) (新)**

   - **职责**：通用事件显示弹窗，包括奥术直觉考验提示、临时Debuff等。

   - **实现**：简单的弹窗场景，包含文本框、标题和确认按钮。

   - `EventPopup.gd` 方法

     ：

     - `show_popup(title: String, description: String, on_confirm_callback: Callable)`: 设置文本，显示，连接确认按钮。

   - **监听信号**：`EventManager.random_event_triggered`, `EventManager.arcane_intuition_started`, `EventManager.arcane_intuition_finished`。

### **阶段五：流程整合与初步测试**

**目标**：将所有模块连接起来，确保游戏流程顺畅，并进行初步功能测试。

1. **主游戏场景 (`cs/主场景/MainGame.gd`)**

   - **职责**：现在 `MainGame` 变得非常薄，主要负责场景切换和信号监听/转发，确保游戏阶段流转。

   - 方法

     ：

     - ```
       _ready()
       ```

       :

       - **连接所有单例信号**：`GameManager`, `EventManager`, `CardManager`。
       - 获取所有UI子场景节点的引用 (`HandDock`, `Sidebar`, `DeckWidget` 等)。

     - `_start_game()`: 调用 `GameManager.initialize_game_state()`，然后 `GameManager.start_new_year(1)`。

     - 连接 `GameManager` 的核心流程信号

        

       (

       ```
       new_year_started
       ```

       ,

        

       ```
       term_started
       ```

       ,

        

       ```
       term_ended
       ```

       ,

        

       ```
       wisdom_hall_opened
       ```

       ,

        

       ```
       assessment_started
       ```

       ,

        

       ```
       game_won
       ```

       ,

        

       ```
       game_lost
       ```

       ) 来：

       - `_on_new_year_started()`: 应用学年主题/限制（通过调用 `EventManager` 方法），然后 `GameManager.start_term(SPRING)`。
       - `_on_term_started()`: 调用 `CardManager.deal_initial_hand(GameManager.get_current_hand_size())` 开始研习回合。
       - `_on_term_ended()`: 加载并显示 `TermRewardUI` 场景。
       - `_on_wisdom_hall_opened()`: 加载并显示 `WisdomHallUI` 场景。
       - `_on_assessment_started()`: 加载并显示 `AssessmentUI` 场景。
       - `_on_game_won()` / `_on_game_lost()`: 切换到胜利/失败场景。

     - 连接 `HandDock` 的操作信号

       ：

       - `_on_play_cards_requested(cards: Array[CardData])`: 转发给 `CardManager.play_selected_cards(cards)`.
       - `_on_discard_cards_requested(cards: Array[CardData])`: 转发给 `CardManager.discard_selected_cards(cards)`.

     - **连接 `TermRewardUI.rewards_claimed` 信号**，在奖励领取后调用 `GameManager.start_wisdom_hall()`。

     - **连接 `WisdomHallUI.wisdom_hall_closed` 信号**，在商店关闭后，根据 `GameManager.current_term` 决定是进入下一学期还是冬季考核。

     - **连接 `EventManager` 的事件信号** (`random_event_triggered`, `arcane_intuition_started`, `arcane_intuition_finished`)，弹出对应的 `EventPopup`。

2. **信号连接概览 (示例)**

   - ```
     GameManager
     ```

      

     Emits:

      

     ```
     game_state_changed
     ```

     ,

      

     ```
     player_abilities_changed
     ```

     ,

      

     ```
     card_type_levels_changed
     ```

     ,

      

     ```
     new_year_started
     ```

     ,

      

     ```
     term_started
     ```

     ,

      

     ```
     term_ended
     ```

     ,

      

     ```
     wisdom_hall_opened
     ```

     ,

      

     ```
     assessment_started
     ```

     ,

      

     ```
     game_won
     ```

     ,

      

     ```
     game_lost
     ```

     ,

      

     ```
     lore_changed
     ```

     ,

      

     ```
     spell_used
     ```

     - Listened by: `MainGame`, `Sidebar`, `WisdomHallManager`, `AssessmentManager`, `TermRewardManager`, `EventManager` (某些信号触发其内部清理/更新)

   - ```
     CardManager
     ```

      

     Emits:

      

     ```
     hand_changed
     ```

     ,

      

     ```
     deck_changed
     ```

     ,

      

     ```
     cards_played
     ```

     - Listened by: `HandDock`, `Sidebar`, `DeckBrowserUI`, `AssessmentManager` (监听 `cards_played` 来累加考核分数)

   - ```
     HandDock
     ```

      

     Emits:

      

     ```
     play_cards_requested
     ```

     ,

      

     ```
     discard_cards_requested
     ```

     ,

      

     ```
     spell_button_pressed
     ```

     - Listened by: `MainGame` (转发给 `CardManager` 或 `GameManager`)

   - ```
     EventManager
     ```

      

     Emits:

      

     ```
     arcane_intuition_started
     ```

     ,

      

     ```
     arcane_intuition_finished
     ```

     ,

      

     ```
     buff_applied
     ```

     ,

      

     ```
     debuff_applied
     ```

     ,

      

     ```
     random_event_triggered
     ```

     - Listened by: `MainGame` (for UI popups), `Sidebar` (for buff/debuff icons)

   - ```
     TermRewardManager
     ```

      

     Emits:

      

     ```
     rewards_claimed
     ```

     - Listened by: `MainGame`

   - ```
     WisdomHallManager
     ```

      

     Emits:

      

     ```
     wisdom_hall_closed
     ```

     - Listened by: `MainGame`

### **阶段六：功能实现与测试（迭代循环）**

**目标**：逐步实现所有法器、法术、守护灵的具体效果，并进行测试和平衡。

1. **法器、法术、守护灵效果实现**

   - 回到 `GameManager.trigger_effect_logic(effect_data: Dictionary, trigger_params: Dictionary)` 方法。

   - 根据 `effect_data.type` 字段，使用 `match` 语句或 `if/else if` 来实现具体的逻辑。

   - 示例

     ：

     ```
     func trigger_effect_logic(effect_data: Dictionary, trigger_params: Dictionary = {}):
         var effect_type = effect_data.type
         var value = effect_data.get("value", null) # 效果通用参数
         var target_id = trigger_params.get("target_id", null) # 目标ID
         var cards = trigger_params.get("cards", []) # 相关的卡牌列表
     
         match effect_type:
             "ADD_LORE":
                 add_lore(value)
             "MODIFY_HAND_SIZE":
                 player_hand_size_modifier += value
             "ADD_CARD_REINFORCEMENT": # 比如 "秘法研磨器" 给手牌加蜡封
                 if cards.size() > 0:
                     var target_card = cards[0] # 或随机选择
                     CardManager.add_reinforcement_to_card_in_hand(target_card.id, value.type, value.effect)
             "TRIGGER_CARD_EFFECT": # 比如蜡封触发的效果
                 if target_id != null:
                     var card_in_hand = CardManager.get_card_in_hand_by_id(target_id) # CardManager 需要新方法
                     if card_in_hand:
                        # 根据 card_in_hand 的强化类型和值再次调用 trigger_effect_logic
                        pass 
             "PERMANENTLY_REMOVE_CARD": # 比如 "解构术", "残酷法则"
                 if target_id != null:
                     CardManager.remove_card_from_deck(target_id)
             "ADD_CARD_TO_DECK": # 比如 "创世符文", "牌库扩容器"
                 var new_card_data = CardData.new() # 或从预设资源加载
                 # ... 根据 value 设置 new_card_data 的属性和强化
                 CardManager.add_card_to_deck(new_card_data)
             # ... 实现所有法器、法术、守护灵的 effect_type
             _:
                 print("Unhandled effect type: ", effect_type)
     ```

   - **注意点**：`trigger_effect_logic` 应该是一个**通用调度器**。它不应该直接包含太多具体游戏的逻辑，而是调用 `GameManager` 或 `CardManager` 中已经定义好的更细粒度的方法。例如，`"ADD_LORE"` 效果调用 `GameManager.add_lore()`，而 `ADD_CARD_REINFORCEMENT` 调用 `CardManager.add_reinforcement_to_card_in_hand()`。

2. **小规模运行调试与聚合**

   - 每次实现一个新法器/法术/守护灵

     ：

     - 在 `assets/data/` 目录下创建其 `.tres` 文件。
     - 在 `GameManager.trigger_effect_logic()` 中添加其 `effect_type` 的处理逻辑。
     - 在 `WisdomHallManager` 的 `refresh_shop_offers()` 中，暂时提高其在商店出现的概率，或手动在 `GameManager.initialize_game_state()` 中将其添加到初始能力列表中。
     - **运行游戏，进行测试**：反复使用该能力，验证其效果是否按照GDD预期触发，是否影响了分数、资源、牌库等，以及是否产生了副作用或错误。

   - **流派测试**：当您实现了一组相互协作的能力后，尝试只选择这些能力的派系（或手动添加这些能力），然后玩一局完整的游戏，看看这个流派的强度和手感。

------

通过这种方式，您将能够：

- **始终保持代码可运行和可调试**。
- **逐步增加功能复杂度**。
- **保持模块职责清晰**，因为每个功能都是围绕其核心职责实现的。
- **利用信号系统实现松耦合**，当一个模块的内部逻辑改变时，通常不会影响其他模块。

这虽然是一个漫长的过程，但每一步的成果都是可见和可验证的，这将极大地提高项目完成的效率和质量。祝您开发顺利！