# 手牌构建技术文档

## 📋 目录
1. [系统架构概述](#系统架构概述)
2. [核心组件详解](#核心组件详解)
3. [构建流程详解](#构建流程详解)
4. [代码实现示例](#代码实现示例)
5. [常见问题与解决方案](#常见问题与解决方案)
6. [性能优化建议](#性能优化建议)

---

## 🏗️ 系统架构概述

### 架构模式：MVC (Model-View-Controller)

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   CardData      │    │   CardView      │    │ HandManager     │
│   (Model)       │◄──►│   (View)        │◄──►│ (Controller)    │
│                 │    │                 │    │                 │
│ • 数据存储      │    │ • 视觉显示      │    │ • 逻辑控制      │
│ • 属性管理      │    │ • 用户交互      │    │ • 事件处理      │
│ • 状态维护      │    │ • 动画效果      │    │ • 状态管理      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 依赖关系图

```
ResourcePaths.gd (静态工具类)
	↓
CardData.gd (数据模型)
	↓
CardView.gd (视图控制器)
	↓
Card.tscn (场景文件)
	↓
HandManager (手牌管理器)
```

---

## 🧩 核心组件详解

### 1. CardData.gd - 卡片数据模型

**职责**: 存储和管理单张卡片的所有数据

**核心属性**:
```gdscript
class_name CardData extends Resource

# 基础属性
@export var id: String = ""           # 唯一标识符，如"H3"表示红桃3
@export var base_value: int = 0       # 基础点数 (1-13)
@export var suit: String = ""         # 花色 ("hearts", "diamonds", "clubs", "spades")
@export var name: String = ""         # 显示名称，如"红桃3"
@export var image_path: String = ""   # 图片资源路径

# 强化属性
@export var wax_seals: Array[String] = []    # 蜡封效果数组
@export var frame_type: String = ""          # 牌框类型
@export var material_type: String = ""       # 材质类型
```

**关键方法**:
```gdscript
# 获取修正后的数值（考虑强化效果）
func get_modified_value(effect_provider = null) -> int

# 获取花色显示名称
func get_suit_display_name() -> String

# 获取数值显示名称
func get_value_display_name() -> String

# 检查是否有特定强化
func has_wax_seal(seal_type: String) -> bool
func has_frame_reinforcement() -> bool
```

### 2. ResourcePaths.gd - 资源路径管理

**职责**: 统一管理所有资源文件的路径计算

**图片索引映射规则**:
```gdscript
# 52张标准扑克牌的索引映射
var suit_offset = {
	"S": 0,    # 黑桃 (Spades):   1-13  (1.jpg  - 13.jpg)
	"H": 13,   # 红桃 (Hearts):   14-26 (14.jpg - 26.jpg)
	"D": 26,   # 方片 (Diamonds): 27-39 (27.jpg - 39.jpg)
	"C": 39    # 梅花 (Clubs):    40-52 (40.jpg - 52.jpg)
}

# 计算公式: 图片索引 = 花色偏移量 + 卡片数值
# 例如: 红桃3 = 13 + 3 = 16.jpg
```

**路径生成示例**:
```gdscript
# 输入: "H3" (红桃3)
# 输出: "res://assets/images/pokers/16.jpg"

static func get_card_image_path(card_id: String) -> String:
	var suit = card_id[0]              # "H"
	var value = card_id.substr(1)      # "3"
	var index = suit_offset[suit] + int(value)  # 13 + 3 = 16
	return CARD_IMAGES_PATH + str(index) + ".jpg"
```

### 3. CardView.gd - 卡片视图控制器

**职责**: 管理单张卡片的视觉显示和用户交互

**核心组件引用**:
```gdscript
# 视觉组件
@onready var front_texture: TextureRect = $CardFront
@onready var back_texture: TextureRect = $CardBack
@onready var card_name_label: Label = $CardFront/NameLabel
@onready var card_element_label: Label = $CardFront/ElementLabel
@onready var card_power_label: Label = $CardFront/PowerLabel

# 强化效果组件
@onready var frame_node: Node2D = $ReinforcementEffects/Frame
@onready var wax_seals_container: Node2D = $ReinforcementEffects/WaxSeals
@onready var material_effect: ColorRect = $ReinforcementEffects/Material
```

**信号系统**:
```gdscript
# 用户交互信号
signal card_clicked(card_view)
signal card_dragged(card_view)
signal card_dropped(card_view, drop_position)
signal card_hovered(card_view)
signal card_unhovered(card_view)
signal selection_changed(card_view, is_selected)
```

### 4. Card.tscn - 卡片场景结构

**节点层次结构**:
```
Card (Control) - 根节点
├── CardFront (TextureRect) - 正面显示
│   ├── NameLabel (Label) - 卡片名称
│   ├── ElementLabel (Label) - 花色符号
│   └── PowerLabel (Label) - 点数显示
├── CardBack (TextureRect) - 背面显示
├── Highlight (Panel) - 高亮效果
├── ReinforcementEffects (Node2D) - 强化效果容器
│   ├── Frame (Node2D) - 牌框效果
│   ├── WaxSeals (Node2D) - 蜡封效果
│   └── Material (ColorRect) - 材质效果
└── AnimationPlayer - 动画播放器
```

---

## 🔄 构建流程详解

### 阶段一: 数据准备

```gdscript
# 1.1 创建卡片数据实例
var card_data = CardData.new()

# 1.2 设置基础属性
card_data.id = "H3"                    # 设置唯一ID
card_data.base_value = 3               # 设置基础点数
card_data.suit = "hearts"              # 设置花色
card_data.name = "红桃3"               # 设置显示名称

# 1.3 计算并设置图片路径
card_data.image_path = ResourcePaths.get_card_image_path("H3")
# 结果: "res://assets/images/pokers/16.jpg"

# 1.4 数据验证
if not validate_card_data(card_data):
	push_error("卡片数据验证失败")
	return null
```

### 阶段二: 视图创建

```gdscript
# 2.1 加载卡片场景
var CardScene = preload("res://cs/卡牌系统/视图/Card.tscn")

# 2.2 实例化场景
var card_view = CardScene.instantiate()
if not card_view:
	push_error("卡片视图创建失败")
	return null

# 2.3 绑定数据到视图
card_view.setup(card_data)

# 2.4 配置视图属性
card_view.scale = Vector2(0.8, 0.8)    # 设置缩放
card_view.set_draggable(true)          # 启用拖拽
```

### 阶段三: 数据绑定

```gdscript
# 3.1 setup方法内部流程
func setup(new_card_data: CardData):
	card_data = new_card_data          # 保存数据引用
	update_view()                      # 更新视图显示

# 3.2 update_view方法详解
func update_view():
	# 3.2.1 加载卡片图片
	var texture = load(card_data.image_path)
	front_texture.texture = texture
	
	# 3.2.2 更新文本标签
	card_name_label.text = card_data.name
	card_element_label.text = card_data.get_suit_display_name()
	card_power_label.text = card_data.get_value_display_name()
	
	# 3.2.3 应用强化效果
	update_reinforcement_effects()
```

### 阶段四: 集成到手牌

```gdscript
# 4.1 添加到场景树
hand_container.add_child(card_view)

# 4.2 添加到数据管理
hand_cards.append(card_data)
hand_views.append(card_view)

# 4.3 设置位置和布局
arrange_hand_layout()

# 4.4 连接信号处理
card_view.card_clicked.connect(_on_card_clicked)
card_view.card_dragged.connect(_on_card_dragged)
```

---

## 💻 代码实现示例

### 完整的单卡构建函数

```gdscript
func create_card(card_id: String, value: int, suit: String, name: String) -> Control:
	"""
	创建单张卡片的完整流程
	
	参数:
		card_id: 卡片ID，如"H3"
		value: 卡片数值，1-13
		suit: 花色，"hearts"/"diamonds"/"clubs"/"spades"
		name: 显示名称，如"红桃3"
	
	返回:
		Control: 创建好的卡片视图，失败返回null
	"""
	
	# 步骤1: 创建并验证数据
	var card_data = CardData.new()
	card_data.id = card_id
	card_data.base_value = value
	card_data.suit = suit
	card_data.name = name
	card_data.image_path = ResourcePaths.get_card_image_path(card_id)
	
	if not _validate_card_data(card_data):
		push_error("卡片数据验证失败: " + card_id)
		return null
	
	# 步骤2: 创建视图
	var CardScene = preload("res://cs/卡牌系统/视图/Card.tscn")
	var card_view = CardScene.instantiate()
	
	if not card_view:
		push_error("卡片视图创建失败: " + card_id)
		return null
	
	# 步骤3: 绑定数据
	card_view.setup(card_data)
	
	# 步骤4: 配置属性
	card_view.scale = Vector2(0.8, 0.8)
	card_view.set_draggable(true)
	
	# 步骤5: 连接信号
	_connect_card_signals(card_view)
	
	print("卡片创建成功: %s" % name)
	return card_view

func _validate_card_data(card_data: CardData) -> bool:
	"""验证卡片数据的完整性"""
	if card_data.id.is_empty(): return false
	if card_data.base_value < 1 or card_data.base_value > 13: return false
	if not card_data.suit in ["hearts", "diamonds", "clubs", "spades"]: return false
	if not ResourceLoader.exists(card_data.image_path): return false
	return true

func _connect_card_signals(card_view: Control):
	"""连接卡片信号"""
	if card_view.has_signal("card_clicked"):
		card_view.card_clicked.connect(_on_card_clicked)
	if card_view.has_signal("card_dragged"):
		card_view.card_dragged.connect(_on_card_dragged)
```

### 批量构建手牌

```gdscript
func build_hand_from_data(cards_data: Array[Dictionary]) -> Array[Control]:
	"""
	从数据数组批量构建手牌
	
	参数:
		cards_data: 卡片数据数组，格式如下:
		[
			{"id": "H3", "value": 3, "suit": "hearts", "name": "红桃3"},
			{"id": "S7", "value": 7, "suit": "spades", "name": "黑桃7"},
			...
		]
	
	返回:
		Array[Control]: 创建好的卡片视图数组
	"""
	
	var hand_views: Array[Control] = []
	
	for i in range(cards_data.size()):
		var card_info = cards_data[i]
		
		# 创建单张卡片
		var card_view = create_card(
			card_info.id,
			card_info.value,
			card_info.suit,
			card_info.name
		)
		
		if card_view:
			# 添加到容器
			hand_container.add_child(card_view)
			hand_views.append(card_view)
			
			# 设置手牌位置（扇形排列）
			_set_hand_position(card_view, i, cards_data.size())
		else:
			push_error("创建卡片失败: " + str(card_info))
	
	print("手牌构建完成，共 %d 张卡片" % hand_views.size())
	return hand_views

func _set_hand_position(card_view: Control, index: int, total: int):
	"""设置手牌中卡片的位置（扇形排列效果）"""
	var angle_step = 8.0  # 每张牌之间的角度
	var start_angle = -(total - 1) * angle_step / 2
	var card_angle = start_angle + index * angle_step
	
	# 应用旋转
	card_view.rotation_degrees = card_angle * 0.4
	
	# 设置垂直偏移（中间的牌稍微向上）
	var center_index = total / 2.0
	var distance_from_center = abs(index - center_index)
	var vertical_offset = distance_from_center * 5
	card_view.position.y += vertical_offset
```

---

## ❗ 常见问题与解决方案

### 问题1: 卡片图片不显示

**原因分析**:
- 图片路径计算错误
- 图片文件不存在
- 资源加载失败

**解决方案**:
```gdscript
func debug_card_image(card_id: String):
	var path = ResourcePaths.get_card_image_path(card_id)
	print("计算路径: %s" % path)
	print("文件存在: %s" % ResourceLoader.exists(path))
	
	if ResourceLoader.exists(path):
		var texture = load(path)
		print("加载成功: %s" % (texture != null))
	else:
		print("使用默认图片")
```

### 问题2: 卡片位置不居中

**原因分析**:
- 锚点设置错误
- 容器大小计算错误
- 缩放影响位置计算

**解决方案**:
```gdscript
func center_card_in_container(card_view: Control, container: Control):
	# 等待一帧确保尺寸计算完成
	await get_tree().process_frame
	
	# 使用锚点居中
	card_view.anchor_left = 0.5
	card_view.anchor_top = 0.5
	card_view.anchor_right = 0.5
	card_view.anchor_bottom = 0.5
	
	# 考虑缩放的偏移
	var scale_factor = card_view.scale.x
	card_view.offset_left = -card_view.size.x * scale_factor / 2
	card_view.offset_top = -card_view.size.y * scale_factor / 2
```

### 问题3: 内存泄漏

**原因分析**:
- 卡片视图未正确释放
- 信号连接未断开
- 循环引用

**解决方案**:
```gdscript
func cleanup_hand():
	# 断开所有信号连接
	for card_view in hand_views:
		if is_instance_valid(card_view):
			# 断开信号
			if card_view.card_clicked.is_connected(_on_card_clicked):
				card_view.card_clicked.disconnect(_on_card_clicked)
			
			# 从场景树移除并释放
			card_view.queue_free()
	
	# 清空数组
	hand_views.clear()
	hand_cards.clear()
```

---

## ⚡ 性能优化建议

### 1. 对象池模式

```gdscript
# 卡片对象池，避免频繁创建销毁
var card_pool: Array[Control] = []
var pool_size: int = 20

func get_card_from_pool() -> Control:
	if card_pool.size() > 0:
		return card_pool.pop_back()
	else:
		return CardScene.instantiate()

func return_card_to_pool(card_view: Control):
	card_view.visible = false
	card_view.get_parent().remove_child(card_view)
	card_pool.append(card_view)
```

### 2. 延迟加载

```gdscript
# 只在需要时加载图片资源
func load_card_texture_async(card_data: CardData, card_view: Control):
	var path = card_data.image_path
	
	# 异步加载
	ResourceLoader.load_threaded_request(path)
	
	# 等待加载完成
	while ResourceLoader.load_threaded_get_status(path) != ResourceLoader.THREAD_LOAD_LOADED:
		await get_tree().process_frame
	
	var texture = ResourceLoader.load_threaded_get(path)
	if texture and is_instance_valid(card_view):
		card_view.front_texture.texture = texture
```

### 3. 批量操作优化

```gdscript
# 批量更新，减少重绘次数
func update_hand_batch(cards_data: Array):
	# 暂停自动重绘
	set_process(false)
	
	for card_data in cards_data:
		# 批量更新操作
		update_single_card(card_data)
	
	# 恢复自动重绘，触发一次性重绘
	set_process(true)
	queue_redraw()
```

---

## 📝 总结

手牌构建系统采用了清晰的MVC架构，通过以下关键组件协作：

1. **CardData**: 负责数据存储和管理
2. **ResourcePaths**: 统一资源路径计算
3. **CardView**: 处理视图显示和交互
4. **Card.tscn**: 定义视觉结构

整个流程遵循"数据驱动视图"的原则，确保了代码的可维护性和扩展性。通过合理的错误处理、性能优化和内存管理，系统能够稳定高效地运行。

---

## 🎯 实战案例

### 案例1: 创建标准52张牌库

```gdscript
func create_standard_deck() -> Array[CardData]:
	"""创建标准52张扑克牌"""
	var deck: Array[CardData] = []
	var suits = ["S", "H", "D", "C"]  # 黑桃、红桃、方片、梅花
	var suit_names = ["黑桃", "红桃", "方片", "梅花"]

	for suit_index in range(suits.size()):
		var suit = suits[suit_index]
		var suit_name = suit_names[suit_index]

		for value in range(1, 14):  # A到K
			var card_data = CardData.new()
			card_data.id = suit + str(value)
			card_data.base_value = value
			card_data.suit = _get_suit_name(suit)
			card_data.name = suit_name + _get_value_name(value)
			card_data.image_path = ResourcePaths.get_card_image_path(card_data.id)

			deck.append(card_data)

	return deck

func _get_suit_name(suit_code: String) -> String:
	match suit_code:
		"S": return "spades"
		"H": return "hearts"
		"D": return "diamonds"
		"C": return "clubs"
		_: return ""

func _get_value_name(value: int) -> String:
	match value:
		1: return "A"
		11: return "J"
		12: return "Q"
		13: return "K"
		_: return str(value)
```

### 案例2: 实现洗牌算法

```gdscript
func shuffle_deck(deck: Array[CardData]) -> Array[CardData]:
	"""Fisher-Yates洗牌算法"""
	var shuffled = deck.duplicate()

	for i in range(shuffled.size() - 1, 0, -1):
		var j = randi() % (i + 1)
		var temp = shuffled[i]
		shuffled[i] = shuffled[j]
		shuffled[j] = temp

	return shuffled
```

### 案例3: 发牌到多个玩家

```gdscript
func deal_cards_to_players(deck: Array[CardData], player_count: int, cards_per_player: int) -> Array[Array[CardData]]:
	"""将牌发给多个玩家"""
	var players_hands: Array[Array[CardData]] = []

	# 初始化玩家手牌
	for i in range(player_count):
		players_hands.append([])

	# 轮流发牌
	var card_index = 0
	for round in range(cards_per_player):
		for player in range(player_count):
			if card_index < deck.size():
				players_hands[player].append(deck[card_index])
				card_index += 1

	return players_hands
```

---

## 🔧 调试工具

### 卡片信息查看器

```gdscript
func debug_card_info(card_data: CardData):
	"""打印卡片详细信息用于调试"""
	print("=== 卡片信息 ===")
	print("ID: %s" % card_data.id)
	print("名称: %s" % card_data.name)
	print("数值: %d" % card_data.base_value)
	print("花色: %s" % card_data.suit)
	print("图片路径: %s" % card_data.image_path)
	print("文件存在: %s" % ResourceLoader.exists(card_data.image_path))

	if card_data.wax_seals.size() > 0:
		print("蜡封: %s" % str(card_data.wax_seals))
	if card_data.frame_type != "":
		print("牌框: %s" % card_data.frame_type)

	print("===============")
```

### 手牌状态监控

```gdscript
func monitor_hand_state(hand_cards: Array[CardData], hand_views: Array[Control]):
	"""监控手牌状态"""
	print("=== 手牌状态 ===")
	print("数据数量: %d" % hand_cards.size())
	print("视图数量: %d" % hand_views.size())

	for i in range(min(hand_cards.size(), hand_views.size())):
		var card = hand_cards[i]
		var view = hand_views[i]
		print("卡片 %d: %s - 视图有效: %s" % [i+1, card.name, is_instance_valid(view)])

	print("===============")
```

---

## 📚 扩展功能

### 卡片动画系统

```gdscript
func animate_card_deal(card_view: Control, target_position: Vector2, delay: float = 0.0):
	"""卡片发牌动画"""
	var tween = create_tween()

	# 设置初始位置（牌堆位置）
	card_view.position = Vector2(-200, -100)
	card_view.rotation_degrees = 0
	card_view.scale = Vector2(0.5, 0.5)

	# 延迟开始
	if delay > 0:
		await get_tree().create_timer(delay).timeout

	# 移动到目标位置
	tween.parallel().tween_property(card_view, "position", target_position, 0.5)
	tween.parallel().tween_property(card_view, "scale", Vector2(0.8, 0.8), 0.5)
	tween.parallel().tween_property(card_view, "rotation_degrees", randf_range(-5, 5), 0.5)

	# 设置缓动效果
	tween.set_ease(Tween.EASE_OUT)
	tween.set_trans(Tween.TRANS_BACK)

func animate_card_flip(card_view: Control):
	"""卡片翻转动画"""
	var tween = create_tween()

	# 第一阶段：缩放到0（隐藏）
	tween.tween_property(card_view, "scale:x", 0.0, 0.15)

	# 中间：切换正反面
	tween.tween_callback(func(): card_view.flip_card())

	# 第二阶段：恢复缩放（显示）
	tween.tween_property(card_view, "scale:x", 0.8, 0.15)
```

### 卡片选择系统

```gdscript
class_name CardSelector extends RefCounted

var selected_cards: Array[Control] = []
var max_selection: int = 5
var selection_changed: Signal

func select_card(card_view: Control) -> bool:
	"""选择卡片"""
	if card_view in selected_cards:
		return false  # 已经选中

	if selected_cards.size() >= max_selection:
		return false  # 超出选择上限

	selected_cards.append(card_view)
	card_view.set_selected(true)
	selection_changed.emit(selected_cards)
	return true

func deselect_card(card_view: Control) -> bool:
	"""取消选择卡片"""
	var index = selected_cards.find(card_view)
	if index == -1:
		return false  # 未选中

	selected_cards.remove_at(index)
	card_view.set_selected(false)
	selection_changed.emit(selected_cards)
	return true

func clear_selection():
	"""清空选择"""
	for card_view in selected_cards:
		card_view.set_selected(false)
	selected_cards.clear()
	selection_changed.emit(selected_cards)
```

---

## 🎨 UI布局策略

### 手牌排列模式

```gdscript
enum HandLayoutMode {
	LINEAR,      # 线性排列
	FAN,         # 扇形排列
	GRID,        # 网格排列
	CIRCULAR     # 圆形排列
}

func arrange_hand(cards: Array[Control], mode: HandLayoutMode, container: Control):
	"""根据模式排列手牌"""
	match mode:
		HandLayoutMode.LINEAR:
			_arrange_linear(cards, container)
		HandLayoutMode.FAN:
			_arrange_fan(cards, container)
		HandLayoutMode.GRID:
			_arrange_grid(cards, container)
		HandLayoutMode.CIRCULAR:
			_arrange_circular(cards, container)

func _arrange_fan(cards: Array[Control], container: Control):
	"""扇形排列"""
	var total = cards.size()
	if total == 0: return

	var angle_range = 60.0  # 总角度范围
	var angle_step = angle_range / max(1, total - 1)
	var start_angle = -angle_range / 2

	var center = container.size / 2
	var radius = 100.0

	for i in range(total):
		var card = cards[i]
		var angle = start_angle + i * angle_step
		var angle_rad = deg_to_rad(angle)

		# 计算位置
		var pos = Vector2(
			center.x + sin(angle_rad) * radius,
			center.y + cos(angle_rad) * radius
		)

		card.position = pos
		card.rotation_degrees = angle * 0.5  # 轻微旋转
```

这份技术文档现在包含了：

1. **完整的系统架构说明**
2. **详细的组件功能解析**
3. **步骤化的构建流程**
4. **实用的代码示例**
5. **常见问题解决方案**
6. **性能优化建议**
7. **实战案例演示**
8. **调试工具和扩展功能**

文档涵盖了从基础概念到高级应用的所有内容，可以作为开发手牌系统的完整参考指南！
